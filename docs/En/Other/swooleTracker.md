---
title: Swoole Tracker
meta:
  - name: description
    content: easyswoole,Swoole Tracker
  - name: keywords
    content: swoole|swoole extension|swoole framework|easyswoole|Swoole Tracker
---

## Swoole Tracker

[Swoole Tracker](https://www.swoole-cloud.com/tracker.html)is a complete set of enterprise-level PHP and Swoole analysis and debugging tools produced by Swoole. It fully supports the coroutine/non-corridor environment, real-time data visualization, comprehensive analysis of report service status, rapid discovery and accurate positioning of problems and performance bottlenecks. . After installing the swoole_tracker extension, we can bury the points in the various events provided in the EasySwoole for application monitoring.

> The installation of the swoole_tracker extension can be found in the installation documentation https://www.kancloud.cn/swoole-inc/ee-base-wiki/1214079#_24 and can be found at https://www.swoole-cloud.com/ Get support, if you need to customize the local deployment, please contact the framework author or Swoole official customer service.

## Rendering

### Application monitoring
![](/resources/img3.png)

### Debugger - process list
![](/resources/img1.png)

> The following is the debugging toolchain function in the enterprise version. Remote debugging is enabled through PID, which supports detection of blocking IO, memory leak and code performance analysis.

### Debugger - blocking detection
![](/resources/img4.png)

### Debugger - Memory Leak Detection
![](/resources/img6.png)

### Debugger - performance analysis
![](/resources/img5.png)

### Interface monitoring
![](/resources/img2.png)


## start up

After installing the swoole_tracker extension, we execute:
```php
/opt/swoole/script/php/swoole_php /opt/swoole/node-agent/src/node.php & php easyswoole start
```
The EasySwoole can be monitored.

## Use

### No need to modify the code

The `v2.5.0` version of Swoole Tracker supports automatic generation of application names and creation of applications without modifying any code. The generated application name format is:

`Swoole`: `HttpServer`：`ip:prot`

others`Server`：`ip(hostname):prot`

### Modify code

You need to modify the code when you need to customize the app name:

### Http service monitoring

#### Global monitoring

In `EasySwooleEvent.php`, register the two events `onRequest`, `afterResponse` respectively.

- onRequest event
```php
public static function onRequest(Request $request, Response $response): bool
{
    $tick = \SwooleTracker\Stats::beforeExecRpc($request->getUri()->getPath(), 'serviceName', "192.168.0.1");
    /*
        Host the tick generated by the request to the context manager
    */
    ContextManager::getInstance()->set("SWOOLE_TRACKER_TICK",$tick);
    return true;
}
```
- afterRequest event
```php
public static function afterRequest(Request $request, Response $response): void
{
    $tick = ContextManager::getInstance()->get('SWOOLE_TRACKER_TICK');
    if($response->getStatusCode() != 200){
        $ret = false;
    }else{
       $ret = true;
    }
    \SwooleTracker\Stats::afterExecRpc($tick, $ret, $response->getStatusCode());
}
```
After registering the above events, all the link information of the `Http` service will be automatically reported to the Swoole Tracker server.

#### Http group monitoring

If you need to do detailed packet monitoring of the Http service, we can define a Base controller.
```php
class Base extends Controller
{
    public $tick;
    
    function onRequest(?string $action): ?bool
    {
        $this->tick = \SwooleTracker\Stats::beforeExecRpc($request->getUri()->getPath(), 'myGroupName', "192.168.0.1");
        return true;
    }
    
    function afterAction(?string $actionName): void
    {
        \SwooleTracker\Stats::afterExecRpc($tick, true, 200);
        $this->tick = null;
    }
}
```

For example, all the Api controllers need to be monitored, so the corresponding controller inherits the corresponding Base controller.


### Rpc, Tcp, WebSocket service monitoring

Easyswoole's Rpc, Tcp, and WebSocket services also provide onRequest, afterAction methods, and bury the two methods to achieve corresponding monitoring.
